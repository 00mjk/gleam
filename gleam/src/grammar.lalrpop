// vi: ft=rust

use std::str::FromStr;

use crate::ast::{Expr, Clause, Scope};
use crate::pattern::Pattern;
use crate::parser::*;

grammar;

pub Expr: Expr<()> = {
    Let => <>,
    Seq => <>,
    SingleExpr => <>,
}

SingleExpr: Expr<()> = {
    Nil => <>,
    Int => <>,
    Var => <>,
    Cons => <>,
    Call => <>,
    Atom => <>,
    Float => <>,
    Tuple => <>,
    String => <>,
    // Fun => <>,
    // BinOp => <>,
    // Case => <>,
    RecordNil => <>,
    Constructor => <>,
    // RecordCons => <>,
    // RecordSelect => <>,
    // ModuleSelect => <>,
}

Let: Expr<()> = {
    <s:@L> <p:Pattern> "=" <v:SingleExpr> <e:@L> <t:Expr> => Expr::Let {
        meta: meta(s, e),
        typ: (),
        value: Box::new(v),
        clause: Clause {
            meta: meta(s, e),
            typ: (),
            pattern: p,
            then: Box::new(t),
        }
    }
}

Seq: Expr<()> = {
    <s:@L> <a:SingleExpr> <b:Expr> <e:@L> => Expr::Seq {
        meta: meta(s, e),
        first: Box::new(a),
        then: Box::new(b),
    }
}

Constructor: Expr<()> = {
    <s:@L> <n:ConstructorName> <e:@L> => Expr::Constructor {
        meta: meta(s, e),
        typ: (),
        name: n,
    },
}

Call: Expr<()> = {
    <s:@L> <fun:SingleExpr> "(" <args:Comma<Expr>> ")" <e:@L> => Expr::Call {
        meta: meta(s, e),
        typ: (),
        fun: Box::new(fun),
        args: args,
    }
}

Tuple: Expr<()> = {
    <s:@L> "{" <elems:Comma<Expr>> "}" <e:@L> => Expr::Tuple {
        meta: meta(s, e),
        typ: (),
        elems: elems,
    }
}

Cons: Expr<()> = {
    <s:@L> "[" <head:Expr> "|" <tail:Expr> "]" <e:@L> => Expr::Cons {
        meta: meta(s, e),
        typ: (),
        head: Box::new(head),
        tail: Box::new(tail),
    }
}

Var: Expr<()> = {
    <s:@L> <v:VarName> <e:@L> => Expr::Var {
        meta: meta(s, e),
        typ: (),
        name: v,
        scope: Scope::Local,
    }
}

Nil: Expr<()> = {
    <s:@L> "[]" <e:@L> => Expr::Nil {
        meta: meta(s, e),
        typ: (),
    }
}

RecordNil: Expr<()> = {
    <s:@L> "{}" <e:@L> => Expr::RecordNil {
        meta: meta(s, e),
    }
}

// TODO: Unescape?
Atom: Expr<()> = {
    <s:@L> <x:r"'(([^\\']|\\.)*)'"> <e:@L> => Expr::Atom {
        meta: meta(s, e),
        value: x[1..(x.len() - 1)].to_string(),
    }
}

// TODO: Unescape?
String: Expr<()> = {
    <s:@L> <x:r#""(([^\\"]|\\.)*)""#> <e:@L> => Expr::String {
        meta: meta(s, e),
        value: x[1..(x.len() - 1)].to_string(),
    }
}

Int: Expr<()> = {
    <s:@L> <i:r"-?[0-9]+"> <e:@L> => Expr::Int {
        meta: meta(s, e),
        value: i64::from_str(i).unwrap(),
    }
}

Float: Expr<()> = {
    <s:@L> <f:r"-?[0-9]+\.+[0-9]*"> <e:@L> => Expr::Float {
        meta: meta(s, e),
        value: f64::from_str(f).unwrap(),
    }
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Pattern: Pattern = {
    PatternVar => <>,
    // PatternInt => <>,
    // PatternNil => <>,
    // PatternCons => <>,
    // PatternAtom => <>,
    // PatternEnum => <>,
    // PatternFloat => <>,
    // PatternTuple => <>,
    // PatternString => <>,
    // PatternRecordNil => <>,
    // PatternRecordCons => <>,
}

PatternVar: Pattern = {
    <s:@L> <v:VarName> <e:@L> => Pattern::Var {
        meta: meta(s, e),
        name: v,
    }
}

VarName: String = {
    <v:r"[a-z][a-z_]*"> => v.to_string()
}

ConstructorName: String = {
    <v:r"[A-Z][A-Za-z_]*"> => v.to_string()
}
